var $jscomp = {
    scope: {}
};
$jscomp.defineProperty = "function" == typeof Object.defineProperties ? Object.defineProperty: function(a, c, b) {
    if (b.get || b.set) throw new TypeError("ES3 does not support getters and setters.");
    a != Array.prototype && a != Object.prototype && (a[c] = b.value)
};
$jscomp.getGlobal = function(a) {
    return "undefined" != typeof window && window === a ? a: "undefined" != typeof global ? global: a
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function() {
    $jscomp.initSymbol = function() {};
    $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol)
};
$jscomp.symbolCounter_ = 0;
$jscomp.Symbol = function(a) {
    return $jscomp.SYMBOL_PREFIX + (a || "") + $jscomp.symbolCounter_++
};
$jscomp.initSymbolIterator = function() {
    $jscomp.initSymbol();
    var a = $jscomp.global.Symbol.iterator;
    a || (a = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
    "function" != typeof Array.prototype[a] && $jscomp.defineProperty(Array.prototype, a, {
        configurable: !0,
        writable: !0,
        value: function() {
            return $jscomp.arrayIterator(this)
        }
    });
    $jscomp.initSymbolIterator = function() {}
};
$jscomp.arrayIterator = function(a) {
    var c = 0;
    return $jscomp.iteratorPrototype(function() {
        return c < a.length ? {
            done: !1,
            value: a[c++]
        }: {
            done: !0
        }
    })
};
$jscomp.iteratorPrototype = function(a) {
    $jscomp.initSymbolIterator();
    a = {
        next: a
    };
    a[$jscomp.global.Symbol.iterator] = function() {
        return this
    };
    return a
};
$jscomp.makeIterator = function(a) {
	console.log("遍历鼠标事件对象");
    $jscomp.initSymbolIterator();
    var c = a[Symbol.iterator];
    console.log("c="+c);
    return c ? c.call(a) : $jscomp.arrayIterator(a)
};
var Operator = function(a, c) {
    this.camera = a;
    this.scene = c;
    this.controls = null;
    this.selComps = [];
    this.renderer = this.ili1 = this.axesHelp = this.tube = null;
    this.aj3 = [];
    this.modelData = null;
    this.aj1 = [];
    this.gvg1 = null;
    this.CurClipInfo = {
        Enable: !1,
        ClipIndex: 0,
        Value: 0
    };
    this.gvg2 = [];
    this.isWalk = this.isAddMark = !1;
    this.redMarkDivs = [];
    this.refreshLedPositionTimer = null;
    this.Empty = Object.freeze([]);
    this.treeRoot = null;
    this.stopRander = !1;
    this.modelName = "";
    this.aj2 = null;
    this.allSelected = [];
    this.helper = null;
    this.isSelectionBox = !1;
    this.ovo1 = this.tvt3 = null;
    this.radius = 100;
    this.theta = 0;
    this.lookAtCenter = !1;
    this.log_face_count = 0;
    this.clipPlanes = [new THREE.Plane(new THREE.Vector3(1, 0, 0), 0), new THREE.Plane(new THREE.Vector3(0, 1, 0), 0), new THREE.Plane(new THREE.Vector3(0, 0, 1), 0), new THREE.Plane(new THREE.Vector3( - 1, 0, 0), 0), new THREE.Plane(new THREE.Vector3(0, -1, 0), 0), new THREE.Plane(new THREE.Vector3(0, 0, -1), 0)]
};
Operator.prototype = {
    ovo2: function(a, c) {
        var b = this;
        this.modelName = a;
        console.log("a=="+a);
        this.propertyTable = document.getElementById("treeTable1");
        var d = document.getElementById("progressLoad"),
        e = document.getElementById("progressDiv");
        b.log_face_count = 0;
        return new Promise(function(g, f) {
            e.style.display = "block";
            b.showLog("start111 \u4e0b\u8f7d\u6a21\u578b");
            b.showLog("start111 下载模型111");
            2 == c && (a += "/default.zip");
            JSZipUtils.getBinaryContent(a,
            function(a, f) {
                function h(a, c) {
                    return new Promise(function(e, d) {
                        var f = c.file("data-" + a + ".json"),
                        f = JSON.parse(f.asText());
                        console.log("Cmps解析=="+b.modelData.Cmps);
                        b.modelData.Cmps.push.apply(b.modelData.Cmps, f);
                        e("1")
                    })
                }
                function k(a, c) {
                    return new Promise(function(e, d) {
                        console.log(a);
                        for (var f = c.file("3d-" + a + ".json"), f = JSON.parse(f.asText()), g = 0; g < f.length; g++) b.gmh3(f[g]);
                        e("1")
                    })
                }
                function u() {
                    b.showLog("\u6784\u4ef6\u6570\u91cf\u4e3a\uff1a" + b.scene.children.length);
                    b.showLog("Face\u6570\u91cf\u4e3a\uff1a" + b.log_face_count);
                    document.getElementById("infoCompCount").innerHTML = b.scene.children.length;
                    document.getElementById("infoAngleCount").innerHTML = b.log_face_count;
                    document.getElementById("infoPointCount").innerHTML = 3 * b.log_face_count;
                    e.style.display = "none"
                }
                if (a) throw a;
                b.showLog("start00 \u89e3\u538b\u6a21\u578b");
                var q = new JSZip(f),
                n = q.file("3d.json"),
                v = q.file("data.json");
                b.showLog("start11 \u53cd\u5e8f\u5217\u5316\u6784\u4ef6");
//                b.showLog("start 3d.json"+JSON.stringify(n));
//                b.showLog("start data.json"+JSON.stringify(v));
               
                var p = JSON.parse(n.asText()),
                n = f = null;
                setTimeout(function() {
                    b.modelData = JSON.parse(v.asText());
//                    console.log("b.modelData=="+JSON.stringify(b.modelData));
//                    b.modelData.Cmps = [];
                    v = null;
                    b.ovo3(0);
                    setTimeout(function() {
                        for (var a = 0; a < b.modelData.GroupCount; a++) h(a, q)
                    },
                    1);
                    console.log("what ````````````\u6570\u636e\u5ef6\u8fdf\u52a0\u8f7d\u5b8c\u6210")
                },
                100);
                b.aj3 = p.SourcePoint;
                if (2 == c) {
                    for (var r = Math.ceil(p.Coms.length / 100), n = 1, m = 0; m < p.Coms.length; m++) r == n && (d.value += 1, n = 1),
                    n++,
                    b.gmh3V3(p.Coms[m]);
                    u()
                } else for (r = p.GroupCount, m = 0; m < p.GroupCount; m++)(function(a) {
                    setTimeout(function() {
                        d.value = 100 * a / r;
                        k(a, q);
                        r == a + 1 && u()
                    },
                    10 * a)
                })(m);
                g("1");
                document.body.background = ""
            })
        })
    },
    ovo4: function(a) {
        var c = this;
        this.modelName = a;
        this.propertyTable = document.getElementById("treeTable1");
        var b = document.getElementById("progressDiv");
        c.log_face_count = 0;
        return new Promise(function(d, e) {
            b.style.display = "block";
            c.showLog("start \u4e0b\u8f7d\u6a21\u578b");
            var g = function(a) {
                a.lengthComputable && console.log(Math.round(a.loaded / a.total * 100, 2) + "% downloaded")
            },
            f = function() {};
            THREE.Loader.Handlers.add(/\.dds$/i, new THREE.DDSLoader); (new THREE.MTLLoader).load(a + ".mtl",
            function(b) {
                b.preload(); (new THREE.OBJLoader).setMaterials(b).load(a + ".obj",
                function(a) {
                    a.position.y = -95;
                    c.scene.add(a);
                    d("1")
                },
                g, f)
            });
            b.style.display = "none"
        })
    },
    ovo3: function(a) {
        var c = this,
        b = this;
        document.getElementById("divBfTree").innerHTML = "";
        var d = new TreeNode("divBfTree  \u5168\u90e8\u5206\u7c7b", b, 0, 0, !1);
        document.getElementById("divBfTree").appendChild(d.element);
        0 == a && this.modelData.Levels.forEach(function(a) {
            var e = new TreeNode(a.Name, b, a.Id, 1, !0);
            d.addChildNode(e);
            c.modelData.Symbles.forEach(function(a) {
                a = new TreeNode(a.text, b, a.Id, 3, !0);
                e.addChildNode(a)
            })
        });
        1 == a ? this.modelData.Symbles.forEach(function(a) {
        	console.log("Symbles=="+Symbles);
            a = new TreeNode(a.text, b, a.Id, 3, !0);
            d.addChildNode(a)
        }) : 2 == a && this.modelData.Levels.forEach(function(a) {
            a = new TreeNode(a.Name, b, a.Id, 1, !0);
            d.addChildNode(a)
        });
        this.treeRoot = d
    },
    ovo5: function() {
        this.gr6e();
        this.ovo6()
    },
    ovo6: function() {
        this.controls.addEventListener("end",
        function() {
            viewer.cc2();
            refreshLedPositionTimer = setTimeout(cc1, 10)
        });
        this.controls.addEventListener("start",
        function() {
            clearTimeout(refreshLedPositionTimer)
        })
    },
    ovo7: function() {
        return this.isSelectionBox
    },
    ovo8: function() { (this.isSelectionBox = !this.isSelectionBox) ? (this.aj2 = new THREE.SelectionBox(this.camera, this.scene), this.helper = new THREE.SelectionHelper(this.aj2, this.renderer, "selectBox"), this.controls.enabled = !1) : (this.helper = this.aj2 = null, this.controls.enabled = !0)
    },
    getMeshById: function(a) {
        this.scene.children.forEach(function(c) {
            if ("Mesh" == c.type && c.rid === a) return c
        })
    },
    getIdOfMesh: function(a) {
        return a.rid
    },
    tot1: function() {
    	console.log("判断是全集还是单构件");
        return this.isSelectionBox ? this.aj2.collection: this.selComps
    },
    gdr2: function(a, c) {
        a.forEach(function(a) {
            "Mesh" == a.type && (a.visible = c)
        })
    },
    setSelectCallback: function(a) {
    	console.log("setSelectCallback"+a)
        this.tvt3 = a
    },
    ng5t: function(a, c) {
        var b = this;
        a.forEach(function(a) {
            "Mesh" == a.type && (c ? b.pvSetSelectColor(a, new Three.Color(c)) : b.pvSetSelectColor(a, null))
        })
    },
    tot12: function(a, c) {
        var b = this;
        a.forEach(function(a) {
            "Mesh" == a.type && b.ah8u(a, c)
        })
    },
    ah8u: function(a, c) {
        a.material.forEach(function(a) {
            a.transparent = 1 != c;
            a.opacity = c
        })
    },
    c48e: function(a) {
        this.gdr2ByTree(0, 0, !a)
    },
    gr6e: function() {
        this.ili1 = new THREE.Group;
        this.ili1.add(new THREE.AxesHelper(20));
        this.ili1.add(new THREE.PlaneHelper(this.clipPlanes[0], 20, 16711680));
        this.ili1.add(new THREE.PlaneHelper(this.clipPlanes[1], 20, 65280));
        this.ili1.add(new THREE.PlaneHelper(this.clipPlanes[2], 20, 255));
        this.ili1.add(new THREE.PlaneHelper(this.clipPlanes[3], 20, 16711680));
        this.ili1.add(new THREE.PlaneHelper(this.clipPlanes[4], 20, 65280));
        this.ili1.add(new THREE.PlaneHelper(this.clipPlanes[5], 20, 255));
        this.ili1.visible = !1;
        this.scene.add(this.ili1);
        this.gvg1 = [[this.clipPlanes[0]], [this.clipPlanes[1]], [this.clipPlanes[2]], [this.clipPlanes[3]], [this.clipPlanes[4]], [this.clipPlanes[5]]];
        this.renderer.clippingPlanes = this.Empty;
        this.renderer.localClippingEnabled = !0
    },
    dr5e: function(a) {
        this.ili1.visible = a
    },
    crh5: function(a) {
        a && !this.isWalk && (this.ili1.children.forEach(function(c) {
            																			c.position.set(a.x, a.y, a.z)
        																			}), console.log("漫游对象=this.ili1.children="+"JSON.stringify(this.ili1.children)")
        )
    },
    SetClipVisible: function(a) {
        var c = this.gvg1[a][0],
        b = this.gvg2.lastIndexOf(c); - 1 === b ? (this.gvg2.push(c), this.CurClipInfo.Value = c.constant, this.CurClipInfo.ClipIndex = a) : this.gvg2.splice(b, 1);
        this.CurClipInfo.Enable = 0 < this.gvg2.length;
        this.renderer.clippingPlanes = this.gvg2
    },
    tot3: function(a, c) {
        var b = this.gvg1[a][0];
        this.CurClipInfo.ClipIndex = a;
        var d = parseInt(c) - 50;
        this.CurClipInfo.Value = 2 * d;
        b.constant = 2 * d
    },
    tot12ByTree: function(a, c, b) {
        var d = this;
        0 == c && 0 == a ? this.scene.children.forEach(function(a) {
            "Mesh" == a.type && d.ah8u(a, b)
        }) : 1 != c && 0 != a ? this.scene.children.forEach(function(e) {
            "Mesh" == e.type && a == e.catid && e.lid === c && d.ah8u(e, b)
        }) : 0 == c ? this.scene.children.forEach(function(c) {
            "Mesh" == c.type && c.catid === a && d.ah8u(c, b)
        }) : 0 == a && this.scene.children.forEach(function(a) {
            "Mesh" == a.type && a.lid === c && d.ah8u(a, b)
        })
    },
    gdr2ByTree: function(a, c, b) {
        var d = !b;
        0 == c && 0 == a ? this.scene.children.forEach(function(a) {
            "Mesh" == a.type && (a.visible = d)
        }) : 1 != c && 0 != a ? this.scene.children.forEach(function(b) {
            "Mesh" == b.type && a == b.catid && b.lid === c && (b.visible = d)
        }) : 0 == c ? this.scene.children.forEach(function(b) {
            "Mesh" == b.type && b.catid === a && (b.visible = d)
        }) : 0 == a && this.scene.children.forEach(function(a) {
            "Mesh" == a.type && a.lid === c && (a.visible = d)
        })
    },
    tot5: function() {
        return JSON.stringify({
            eye: this.camera.position,
            center: 0 < this.redMarkDivs.length ? this.redMarkDivs[0].position: [this.controls.target.x, this.controls.target.y, this.controls.target.z],
            up: this.camera.up,
            rotation: this.camera.rotation,
            target: this.controls.target
        })
    },
    yoy1: function(a) {
        a = JSON.parse(a);
        this.camera.position.set(a.eye.x, a.eye.y, a.eye.z);
        this.camera.rotation.set(a.rotation._x, a.rotation._y, a.rotation._z, "XYZ");
        this.camera.lookAt(a.center);
        this.uu1(a.center);
        this.camera.updateMatrixWorld()
    },
    yoy2: function(a) {
        this.isAddMark = a
    },
    yoy3: function(a, c) {
        if (c) {
            var b = this.uu2(c[0], c[1], c[2]);
            this.thd5(b, c, a)
        } else b = this.getMeshById(a),
        this.yoy4(b, c)
    },
    yoy4: function(a, c) {
        var b = this.uu2(c[0], c[1], c[2]);
        this.thd5(b, c, a.rid)
    },
    tc2: function() {
        for (var a = [], c = 0; c < this.redMarkDivs.length; c++) {
            var b = this.redMarkDivs[c];
            a.push({
                rid: b.meshRid,
                position: b.position
            })
        }
        return JSON.stringify(a)
    },
    yoy5: function(a) {
        var c = this;
        JSON.parse(a).forEach(function(a) {
            c.yoy3(a.rid, a.position)
        })
    },
    thd5: function(a, c, b) {
        var d = document.createElement("div");
        d.classList.add("redmark");
        d.style.position = "absolute";
        d.Name = "Mark" + b;
        var e = this;
        d.onclick = function(a) {
            if (e.ovo1) {
                var b = null;
                a = a.target.parentNode.Name;
                4 < a.length && (b = a.substr(4, a.length - 4));
                e.ovo1(b)
            }
        };
        document.body.appendChild(d);
        d.innerHTML = '\x3cimg src\x3d"css/led_red.png" class\x3d"zoom" style\x3d"position: absolute;"\x3e';
        d.style.display = "";
        d.style.left = a.x - 16 + "px";
        d.style.top = a.y - 16 + "px";
        this.redMarkDivs.push({
            position: c,
            mark: d,
            meshRid: b
        })
    },
    setovo1: function(a) {
        this.ovo1 = a
    },
    mm7: function(a) {
        for (var c = -1,
        b = 0; b < this.redMarkDivs.length; b++) {
            var d = this.redMarkDivs[b];
            if (d.meshRid == a) {
                document.body.removeChild(d.mark);
                c = b;
                break
            }
        } - 1 < c && (this.redMarkDivs = this.redMarkDivs.splice(c, 1))
    },
    mm1: function(a) {
        this.mm7(a.rid)
    },
    mm2: function() {
        for (var a = 0; a < this.redMarkDivs.length; a++) document.body.removeChild(this.redMarkDivs[a].mark);
        this.redMarkDivs = []
    },
    cc1: function() {
        var a = this;
        this.redMarkDivs.forEach(function(c) {
            var b = c.mark;
            c = a.uu2(c.position[0], c.position[1], c.position[2]);
            b.style.display = "";
            b.style.left = c.x - 16 + "px";
            b.style.top = c.y - 16 + "px"
        })
    },
    cc2: function() {
        this.redMarkDivs.forEach(function(a) {
            a.mark.style.display = "none"
        })
    },
    showLog: function(a) {
        console.log(a)
    },
    cc3: function(a) {
        this.renderer = a
    },
    getRenderer: function() {
        return this.renderer
    },
    cc5: function() {
        var a = new THREE.AmbientLight(16777215, .9);
        this.scene.add(a);
        a = new THREE.DirectionalLight(8947848, .8);
        a.position.set(100, 100, -200);
        this.scene.add(a)
    },
    gmh3: function(a) {
        var c = [],
        b = [],
        d = [];
        a.Colors.forEach(function(a) {
            var b = new THREE.MeshLambertMaterial({
                color: a[0],
                vertexColors: THREE.FaceColors,
                transparent: !0,
                side: THREE.DoubleSide,
                wireframe: !1
            });
            0 < a[1] && (b.opacity = .01 * (100 - a[1]));
            d.push(b)
        });
        for (var e = 0; e < a.Vertices.length; e++) {
            var g = a.Vertices[e].split(",");
            c.push(new THREE.Vector3(a.xs[g[0]], a.ys[g[1]], a.zs[g[2]]))
        }
        for (e = 0; e < a.Faces.length; e++) {
            var g = a.Faces[e].split(","),
            f = new THREE.Face3(g[0], g[1], g[2]);
            f.color.setHex(a.Colors[g[3]][0]);
            f.materialIndex = g[3];
            b.push(f)
        }
        this.log_face_count += a.Faces.length;
        e = new THREE.Geometry;
        e.vertices = c;
        e.faces = b;
        e.computeFaceNormals();
        c = new THREE.Mesh(e, d);
        c.position.set(0, 0, 0);
        c.rid = a.Id;
        c.catid = a.CatId;
        c.lid = a.LevelId;
        this.scene.add(c)
    },
    prvAddMtr: function(a, c) {
        var b = parseInt(c[0]);
        "null" == c[2] ? (b = new THREE.MeshLambertMaterial({
            color: b,
            vertexColors: THREE.FaceColors,
            transparent: !0,
            side: THREE.DoubleSide,
            wireframe: !1
        }), 0 < parseInt(c[1]) && (b.opacity = .01 * (100 - parseInt(c[1]))), a.push(b)) : (new THREE.TextureLoader).load(this.modelName + "/" + c[2],
        function(b) {
            var c = new THREE.MeshLambertMaterial({
                map: b
            });
            a.push(c);
            b.wrapS = b.wrapT = THREE.RepeatWrapping;
            b.repeat = new THREE.Vector2(5, 5)
        })
    },
    //3d.json解析
    gmh3V3: function(a) {
        for (var c = [], b = [], d = [], e = [], g = [], f = 0; f < a.Colors.length; f++) this.prvAddMtr(d, a.Colors[f]);
        for (f = 0; f < a.Pt.length; f++) {
            var h = a.Pt[f].split(",");
            c.push(new THREE.Vector3(h[0], h[1], h[2]))
        }
        for (var k = .254 * .1,
        f = 0; f < a.UVs.length; f++) h = a.UVs[f].split(","),
        e.push(new THREE.Vector2(h[0] * k, h[1] * k, h[2] * k));
        h = 1;
        for (f = 0; f < a.Faces.length; f++) for (k = 0; k < a.Faces[f].Tgs.length; k++) {
            var l = a.Faces[f].Tgs[k].split(","),
            t = a.Faces[f].Uvset[k].split(","),
            l = new THREE.Face3(l[0], l[1], l[2]);
            l.color.setHex(parseInt(a.Colors[a.Faces[f].MtrId][0]));
//            console.log("a.Colors[a.Faces[f].MtrId][0]=="+a.Colors[a.Faces[f].MtrId][0]);
            l.materialIndex = a.Faces[f].MtrId;
            h++;
            b.push(l);
//            console.log("l==="+JSON.stringify(l));
//            console.log("t=Uvset=="+JSON.stringify(t));
            l = [];
            l.push(e[t[0]], e[t[1]], e[t[2]]);
            g.push(l)
        }
        this.log_face_count += h;
        e = new THREE.Geometry;
        e.vertices = c;
        e.faces = b;
        e.faceVertexUvs[0] = g;
        e.computeFaceNormals();
        c = new THREE.Mesh(e, d);
        c.position.set(0, 0, 0);
        c.rid = a.Id;
        c.catid = a.CatId;
        c.lid = a.LevelId;
        this.scene.add(c)
        var str = "";
        str = JSON.stringify(c);
//        console.log("3d.json=="+str);
    },
    tt1: function(a) {
        this.axesHelp = new THREE.AxisHelper(a);
        this.scene.add(this.axesHelp)
    },
    tt2: function(a) {
        this.isWalk || this.axesHelp.position.set(a.x, a.y, a.z)
    },
    resize: function() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight)
    },
    rander: function() {
        this.stopRander || (this.isWalk && this.controls.update(.005), this.renderer && (this.renderer.render(this.scene, this.camera), this.lookAtCenter && this.circleRol()))
    },
    circleRol: function() {
        this.theta += .1;
        this.camera.position.x = this.radius * Math.sin(THREE.Math.degToRad(this.theta));
        this.camera.position.y = this.radius * Math.cos(THREE.Math.degToRad(this.theta));
        this.camera.lookAt(this.scene.position);
        this.camera.updateMatrixWorld()
    },
    tt3: function(a) {
        var c = null;
        if (this.CurClipInfo.Enable) {
            if (0 == this.CurClipInfo.ClipIndex) for (var b = 0; b < a.length; b++) if (a[b].point.x > this.CurClipInfo.Value) {
                c = a[b];
                break
            }
            if (1 == this.CurClipInfo.ClipIndex) for (b = 0; b < a.length; b++) if (a[b].point.y > this.CurClipInfo.Value) {
                c = a[b];
                break
            }
            if (2 == this.CurClipInfo.ClipIndex) for (b = 0; b < a.length; b++) if (a[b].point.z > this.CurClipInfo.Value) {
                c = a[b];
                break
            }
            if (3 == this.CurClipInfo.ClipIndex) for (b = 0; b < a.length; b++) if (a[b].point.x < this.CurClipInfo.Value) {
                c = a[b];
                break
            }
            if (4 == this.CurClipInfo.ClipIndex) for (b = 0; b < a.length; b++) if (a[b].point.y < this.CurClipInfo.Value) {
                c = a[b];
                break
            }
            if (5 == this.CurClipInfo.ClipIndex) for (b = 0; b < a.length; b++) if (a[b].point.z < this.CurClipInfo.Value) {
                c = a[b];
                break
            }
        } else c = a[0];
        return c
    },
    sphere: function(a, c, b, d, e) {
        var g = new THREE.SphereGeometry(5, 10, 10);
        d = new THREE.MeshLambertMaterial({
            color: d,
            wireframe: !1,
            transparent: !0,
            side: THREE.DoubleSide,
            opacity: e
        });
        g = new THREE.Mesh(g, d);
        g.position.set(a, c, b);
        this.scene.add(g);
        return g
    },
    tt4: function() {
        if (0 == this.selComps.length) return 0;
        console.log(this.selComps[0]);
        var a = this.selComps[0].geometry;
        a.computeBoundingBox();
        a = a.boundingBox;
        a = [.5 * (a.max.x + a.min.x), .5 * (a.max.y + a.min.y), .5 * (a.max.z + a.min.z)];
        this.controls.target.set(a[0], a[1], a[2]);
        this.controls.update();
        return 1
    },
    uu1: function(a) {
        this.controls.target.set(a[0], a[1], a[2]);
        this.controls.update();
        return 1
    },
    kiul8: function(a) {
        this.controls && this.controls.dispose();
        this.isWalk ? (this.controls = new THREE.FlyControls(this.camera), this.controls.movementSpeed = 100, this.controls.rollSpeed = Math.PI / 6, this.controls.autoForward = !1, this.controls.dragToLook = !0) : (this.controls = new THREE.OrbitControls(this.camera), this.controls.target.set(0, 0, 0), this.controls.update(), 1 === a && this.ovo6());
        return this.controls
    },
    setWalk: function() { (this.isWalk = !this.isWalk) ? (this.scene.remove(this.axesHelp), this.mm2()) : this.scene.add(this.axesHelp);
        return 1
    },
    pvSetSelectColor: function(a, c) {
        a && a.material.length && a.material.forEach(function(a) {
            c ? (a.defaultColor || (a.defaultColor = a.color), a.color = c) : a.defaultColor && (a.color = a.defaultColor)
        })
    },
    mouseDown: function(a) {
    	console.log("mouseDown");
    	console.log("a"+JSON.stringify(a));
    	console.log("this.aj2=="+this.aj2);
    	var reg =/mousedown/;
       /* if (reg.test(a.type)) {
            for (var c = $jscomp.makeIterator(a), b = c.next(); ! b.done; b = c.next()) this.pvSetSelectColor(b.value, null);
            this.aj2.startPoint.set(a.clientX / window.innerWidth * 2 - 1, 2 * -(a.clientY / window.innerHeight) + 1, .5);
            console.log("mouseDown11");
        }*/
        
    },
    onDocumentClick: function (event){
    	var ensureNamespace = function recur(ns, root) {
//    		alert("ensureNamespace");
    	    var parts = typeof ns === 'string' ? ns.split('.') : ns;
    	    var e = root || this;
    	    if (parts[0]) {
    	        var next = parts.shift()
    	        e[next] =e[next] || {};
    	        return recur(parts, e[next]);
    	    }
    	    var str = "";
    	    str = JSON.stringify(e);
    	    console.log("e==="+str);
    	    return e;
    	};

    	// maybe another file:
    	(function(){
    	    var baz = ensureNamespace("foo.bar.baz");
    	    // baz === window.foo.bar.baz;
    	    baz.qux = "Yep";
    	}());

    	
    	
    },
    mouseOver: function(a, c) {
//    	console.log("mouseOver");
        if (this.isSelectionBox && this.helper.isDown) {
            for (var b = 0; b < this.aj2.collection.length; b++) this.pvSetSelectColor(this.aj2.collection[b], null);
            this.aj2.endPoint.set(a.clientX / window.innerWidth * 2 - 1, 2 * -(a.clientY / window.innerHeight) + 1, .5);
            for (var d = this.aj2.select(), b = 0; b < d.length; b++) this.pvSetSelectColor(d[b], new THREE.Color(16776960))
        }
        this.controls.showRay && (b = new THREE.Vector3(a.clientX / window.innerWidth * 2 - 1, 2 * -(a.clientY / window.innerHeight) + 1, .5), b = b.unproject(this.camera), d = (new THREE.Raycaster(this.camera.position, b.sub(this.camera.position).normalize())).intersectObjects(this.components) && console.log("this.components=="+this.components), 0 < d.length && (b = [], b.push(new THREE.Vector3( - 30, 39.8, 30)), b.push(d[0].point), d = new THREE.MeshBasicMaterial({
            color: 16711680,
            transparent: !0,
            opacity: .6
        }), b = new THREE.TubeGeometry(new THREE.SplineCurve3(b), 60, .001), this.tube && this.scene.remove(tube), this.controls.showRay && (this.tube = new THREE.Mesh(b, d), this.scene.add(tube))))
    },
    mouseUp: function(a) {
    	console.log("mouseUp");
        if (this.isSelectionBox) {
        	console.log("玄宗");
            this.aj2.endPoint.set(a.clientX / window.innerWidth * 2 - 1, 2 * -(a.clientY / window.innerHeight) + 1, .5);
            a = this.aj2.select();
            for (var c = 0; c < a.length; c++) this.pvSetSelectColor(a[c], new THREE.Color(16776960));
        } 
        else this.allSelected = [] && console.log("未选中"),
        a = new THREE.Vector3(a.clientX / window.innerWidth * 2 - 1, 2 * -(a.clientY / window.innerHeight) + 1, .5),
        a = a.unproject(this.camera),	
        c = (new THREE.Raycaster(this.camera.position, a.sub(this.camera.position).normalize())).intersectObjects(this.scene.children),
        0 < this.selComps.length && (this.pvSetSelectColor(this.selComps[0], null), this.selComps = []) && console.log("this=="+this),
        /*0 < c.length && (a = this.CurClipInfo.Enable ? this.tt3(c) : c[0], null != a && (console.log(a.object), this.pvSetSelectColor(a.object, 
        		new THREE.Color(16776960)), this.showLog("what+\u70b9\u51fb =" + c[0].object.uuid), this.isAddMark && 
        		(c = [a.point.x, a.point.y, a.point.z], this.isWalk || this.uu1(c), this.yoy4(a.object, c)), 
        		this.selComps.push(a.object), this.tvt3 && this.tvt3(a.object), this.showProperty(a.object.rid) && console.log("testshow")))*/
        0 < c.length && (a = this.CurClipInfo.Enable ? this.tt3(c) : c[0], null != a && (console.log(a.object),
				this.pvSetSelectColor(a.object, new THREE.Color(16776960)),
				this.showLog("what+\u70b9\u51fb =" + c[0].object.uuid /*&& console.log("@@@@@@=="+JSON.stringify(this.modelData)+"###"+JSON.stringify(a.modelData))*/),
				this.isAddMark && (c = [a.point.x, a.point.y, a.point.z],
				this.isWalk || this.uu1(c), this.yoy4(a.object, c)), 
				this.selComps.push(a.object), this.tvt3 && this.tvt3(a.object), this.showProperty(a.object.rid)))
        
        		
//        console.log("AAA=="+JSON.stringify(a.object));
         console.log("---------AAA=="+JSON.stringify(a.object.rid));
//      console.log("								c[0]=="+JSON.stringify(c));
        
       /* var a=a.object.rid;
        console.log("---------aaa=="+JSON.stringify(a));
//        console.log("								c[0]=="+JSON.stringify(c));
        
        b = document.getElementById("tableProperty");
        this.aj1 = [];
//        var abcd =this;
//        console.log("this0=="+JSON.stringify(abcd));
        b.innerHTML = "";
        console.log("122222222222222211"+this.modelData.Cmps);
        this.modelData.Cmps.forEach(function(d) {
            d.Id === a && d.Prmgs.forEach(function(a) {
                var d = new TreeTableNode(b);
                console.log("d=="+d);
                c.aj1.push(d);
                d.addtbTale(a)
            })
        })
        console.log("d=="+d);*/
        //方法二：
        /*var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
        vector = vector.unproject(this.camera);
        var str2 = "";
        str2 = JSON.stringify(vector.object);
        console.log("vector=="+str2);
 
        var vector = new THREE.Vector3((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
        vector = vector.unproject(this.camera);
 
        var raycaster = new THREE.Raycaster(this.camera.position, vector.sub(this.camera.position).normalize());
 
        var intersects = raycaster.intersectObjects(this.components);
        console.log(intersects)
        if (this.selComps.length > 0) {
            this.selComps[0].object.material.transparent = false;
            this.selComps[0].object.material.opacity = 1;
            this.selComps = [];
        }
        if (intersects.length > 0) {
            // console.log(intersects[0]);
            intersects[0].object.material.transparent = true;
            intersects[0].object.material.opacity = 0.5;
            this.showLog('点击' + intersects[0].object.uuid);
            //点击到的位置：intersects[0].point;
            if (this.isAddMark) {
                //todo 对标记进行监管。
                viewer.sphere(intersects[0].point.x, intersects[0].point.y, intersects[0].point.z,0xFF0000,0.7);
            }
            this.selComps.push(intersects[0]);
            this.showProperty(intersects[0].object.rid);
        }*/
    },
    showProperty: function(a) {
//    	console.log("a==="+a);
//    	console.log("this.modelData=="+JSON.stringify(this.modelData));
    	console.log("显示构件");
        var c = this,
        b = document.getElementById("tableProperty");
        this.aj1 = [];
        b.innerHTML = "";
//        console.log("this.modelData=="+this.modelData);
        this.modelData.Cmps.forEach(function(d) {
            d.Id === a && d.Prmgs.forEach(function(a) {
                var d = new TreeTableNode(b);
                c.aj1.push(d);
                d.addtbTale(a)
            })
        })
        
        
    },
    poi8o: function(a) {
        var c = new THREE.Vector3,
        b = .5 * this.renderer.context.canvas.width,
        d = .5 * this.renderer.context.canvas.height;
        a.updateMatrixWorld();
        c.setFromMatrixPosition(a.matrixWorld);
        c.y *= 2;
        c.project(this.camera);
        c.x = c.x * b + b;
        c.y = -(c.y * d) + d;
        return {
            x: c.x,
            y: c.y
        }
    },
    uu2: function(a, c, b) {
        a = new THREE.Vector3(a, c, b);
        c = .5 * this.renderer.context.canvas.width;
        b = .5 * this.renderer.context.canvas.height;
        a.project(this.camera);
        a.x = a.x * c + c;
        a.y = -(a.y * b) + b;
        return {
            x: a.x,
            y: a.y
        }
    }
};
//# sourceMappingURL=view.min.js.map
